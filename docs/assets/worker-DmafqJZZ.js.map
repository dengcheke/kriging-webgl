{"version":3,"file":"worker-DmafqJZZ.js","sources":["../src/kriging.ts","../node_modules/.pnpm/lru-cache@11.1.0/node_modules/lru-cache/dist/esm/index.js","../src/supports.ts","../src/webgl/glsl.ts","../src/webgl/utils.ts","../src/webgl/generate.ts","../test/worker.ts"],"sourcesContent":["/* \r\nCopyright (C) 2011-2013, Omar Olmedo\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \r\n*/\r\n\r\nfunction pip(arr: number[][], x: number, y: number) {\r\n    let result = false;\r\n    for (let i = 0, j = arr.length - 1; i < arr.length; j = i++) {\r\n        if (\r\n            arr[i][1] > y != arr[j][1] > y &&\r\n            x < ((arr[j][0] - arr[i][0]) * (y - arr[i][1])) / (arr[j][1] - arr[i][1]) + arr[i][0]\r\n        ) {\r\n            result = !result;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction createArrayWithValues(value: number, length: number) {\r\n    return new Array<number>(length).fill(value);\r\n}\r\n// Matrix algebra\r\nfunction kriging_matrix_diag(value: number, n: number) {\r\n    const matrix = createArrayWithValues(0, n * n);\r\n    for (let i = 0; i < n; i++) matrix[i * n + i] = value;\r\n    return matrix;\r\n}\r\nfunction kriging_matrix_transpose(matrix: number[], n: number, m: number) {\r\n    const M = Array<number>(m * n);\r\n    for (let i = 0; i < n; i++)\r\n        for (let j = 0; j < m; j++) {\r\n            M[j * n + i] = matrix[i * m + j];\r\n        }\r\n    return M;\r\n}\r\nfunction kriging_matrix_scale(M: number[], scale: number, n: number, m: number) {\r\n    for (let i = 0; i < n; i++) for (let j = 0; j < m; j++) M[i * m + j] *= scale;\r\n}\r\nfunction kriging_matrix_add(Ma: number[], Mb: number[], n: number, m: number) {\r\n    const M = Array<number>(n * m);\r\n    for (let i = 0; i < n; i++)\r\n        for (let j = 0; j < m; j++) {\r\n            const index = i * m + j;\r\n            M[index] = Ma[index] + Mb[index];\r\n        }\r\n    return M;\r\n}\r\n\r\n// Naive matrix multiplication\r\nfunction kriging_matrix_multiply(\r\n    Ma: number[],\r\n    Mb: number[],\r\n    n: number /*前一个的rows*/,\r\n    m: number,\r\n    p: number /*后一个的cols*/\r\n) {\r\n    const Z = Array<number>(n * p).fill(0);\r\n    for (let i = 0; i < n; i++) {\r\n        for (let j = 0; j < p; j++) {\r\n            for (let k = 0, index = i * p + j; k < m; k++) {\r\n                Z[index] += Ma[i * m + k] * Mb[k * p + j];\r\n            }\r\n        }\r\n    }\r\n    return Z;\r\n}\r\n\r\n// Cholesky decomposition\r\nfunction kriging_matrix_chol(M: number[], n: number) {\r\n    const p = Array(n);\r\n    for (let i = 0; i < n; i++) {\r\n        p[i] = M[i * n + i];\r\n    }\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        for (let j = 0; j < i; j++) {\r\n            p[i] -= M[i * n + j] ** 2;\r\n        }\r\n        if (p[i] <= 0) return false;\r\n        p[i] = Math.sqrt(p[i]);\r\n        for (let j = i + 1; j < n; j++) {\r\n            for (let k = 0; k < i; k++) {\r\n                M[j * n + i] -= M[j * n + k] * M[i * n + k];\r\n            }\r\n            M[j * n + i] /= p[i];\r\n        }\r\n    }\r\n    for (let i = 0; i < n; i++) M[i * n + i] = p[i];\r\n    return true;\r\n}\r\n// Inversion of cholesky decomposition\r\nfunction kriging_matrix_chol2inv(M: number[], n: number) {\r\n    let i, j, k, sum;\r\n    for (i = 0; i < n; i++) {\r\n        M[i * n + i] = 1 / M[i * n + i];\r\n        for (j = i + 1; j < n; j++) {\r\n            sum = 0;\r\n            for (k = i; k < j; k++) sum -= M[j * n + k] * M[k * n + i];\r\n            M[j * n + i] = sum / M[j * n + j];\r\n        }\r\n    }\r\n    for (i = 0; i < n; i++) for (j = i + 1; j < n; j++) M[i * n + j] = 0;\r\n    for (i = 0; i < n; i++) {\r\n        M[i * n + i] *= M[i * n + i];\r\n        for (k = i + 1; k < n; k++) M[i * n + i] += M[k * n + i] * M[k * n + i];\r\n        for (j = i + 1; j < n; j++) for (k = j; k < n; k++) M[i * n + j] += M[k * n + i] * M[k * n + j];\r\n    }\r\n    for (i = 0; i < n; i++) for (j = 0; j < i; j++) M[i * n + j] = M[j * n + i];\r\n}\r\n// Inversion via gauss-jordan elimination\r\nfunction kriging_matrix_solve(M: number[], n: number) {\r\n    let m = n;\r\n    let b = Array(n * n);\r\n    let indxc = Array(n);\r\n    let indxr = Array(n);\r\n    let ipiv = Array(n);\r\n    let i, icol, irow, j, k, l, ll;\r\n    let big, dum, pivinv, temp;\r\n\r\n    for (i = 0; i < n; i++)\r\n        for (j = 0; j < n; j++) {\r\n            if (i == j) b[i * n + j] = 1;\r\n            else b[i * n + j] = 0;\r\n        }\r\n    for (j = 0; j < n; j++) ipiv[j] = 0;\r\n    for (i = 0; i < n; i++) {\r\n        big = 0;\r\n        for (j = 0; j < n; j++) {\r\n            if (ipiv[j] != 1) {\r\n                for (k = 0; k < n; k++) {\r\n                    if (ipiv[k] == 0) {\r\n                        if (Math.abs(M[j * n + k]) >= big) {\r\n                            big = Math.abs(M[j * n + k]);\r\n                            irow = j;\r\n                            icol = k;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        ++ipiv[icol];\r\n\r\n        if (irow != icol) {\r\n            for (l = 0; l < n; l++) {\r\n                temp = M[irow * n + l];\r\n                M[irow * n + l] = M[icol * n + l];\r\n                M[icol * n + l] = temp;\r\n            }\r\n            for (l = 0; l < m; l++) {\r\n                temp = b[irow * n + l];\r\n                b[irow * n + l] = b[icol * n + l];\r\n                b[icol * n + l] = temp;\r\n            }\r\n        }\r\n        indxr[i] = irow;\r\n        indxc[i] = icol;\r\n\r\n        if (M[icol * n + icol] == 0) return false; // Singular\r\n\r\n        pivinv = 1 / M[icol * n + icol];\r\n        M[icol * n + icol] = 1;\r\n        for (l = 0; l < n; l++) M[icol * n + l] *= pivinv;\r\n        for (l = 0; l < m; l++) b[icol * n + l] *= pivinv;\r\n\r\n        for (ll = 0; ll < n; ll++) {\r\n            if (ll != icol) {\r\n                dum = M[ll * n + icol];\r\n                M[ll * n + icol] = 0;\r\n                for (l = 0; l < n; l++) M[ll * n + l] -= M[icol * n + l] * dum;\r\n                for (l = 0; l < m; l++) b[ll * n + l] -= b[icol * n + l] * dum;\r\n            }\r\n        }\r\n    }\r\n    for (l = n - 1; l >= 0; l--)\r\n        if (indxr[l] != indxc[l]) {\r\n            for (k = 0; k < n; k++) {\r\n                temp = M[k * n + indxr[l]];\r\n                M[k * n + indxr[l]] = M[k * n + indxc[l]];\r\n                M[k * n + indxc[l]] = temp;\r\n            }\r\n        }\r\n\r\n    return true;\r\n}\r\n\r\n// Variogram models\r\nfunction kriging_variogram_gaussian(h: number, nugget: number, range: number, sill: number, A: number) {\r\n    return nugget + ((sill - nugget) / range) * (1.0 - Math.exp(-(1.0 / A) * Math.pow(h / range, 2)));\r\n}\r\nfunction kriging_variogram_exponential(h: number, nugget: number, range: number, sill: number, A: number) {\r\n    return nugget + ((sill - nugget) / range) * (1.0 - Math.exp(-(1.0 / A) * (h / range)));\r\n}\r\nfunction kriging_variogram_spherical(h: number, nugget: number, range: number, sill: number, A: number) {\r\n    if (h > range) return nugget + (sill - nugget) / range;\r\n    return nugget + ((sill - nugget) / range) * (1.5 * (h / range) - 0.5 * Math.pow(h / range, 3));\r\n}\r\n\r\nexport interface Variogram {\r\n    t: number[];\r\n    x: number[];\r\n    y: number[];\r\n    nugget: number;\r\n    range: number;\r\n    sill: number;\r\n    A: number;\r\n    n: number;\r\n    K: number[];\r\n    M: number[];\r\n    model: KrigingModel;\r\n}\r\n\r\nexport type KrigingModel = \"gaussian\" | \"exponential\" | \"spherical\";\r\n\r\nfunction getModelFn(type: KrigingModel) {\r\n    switch (type) {\r\n        case \"gaussian\":\r\n            return kriging_variogram_gaussian;\r\n        case \"exponential\":\r\n            return kriging_variogram_exponential;\r\n        case \"spherical\":\r\n            return kriging_variogram_spherical;\r\n    }\r\n}\r\n\r\nexport function train(t: number[], x: number[], y: number[], model: KrigingModel, sigma2: number, alpha: number) {\r\n    const variogram = {\r\n        t: t,\r\n        x: x,\r\n        y: y,\r\n        nugget: 0.0,\r\n        range: 0.0,\r\n        sill: 0.0,\r\n        A: 1 / 3,\r\n        n: 0,\r\n        model,\r\n    } as Variogram;\r\n    const modelFn = getModelFn(model);\r\n\r\n    // Lag distance/semivariance\r\n    var i,\r\n        j,\r\n        k,\r\n        l,\r\n        n = t.length;\r\n    var distance = Array((n * n - n) / 2);\r\n    for (i = 0, k = 0; i < n; i++)\r\n        for (j = 0; j < i; j++, k++) {\r\n            distance[k] = Array(2);\r\n            distance[k][0] = Math.pow(Math.pow(x[i] - x[j], 2) + Math.pow(y[i] - y[j], 2), 0.5);\r\n            distance[k][1] = Math.abs(t[i] - t[j]);\r\n        }\r\n    distance.sort(function (a, b) {\r\n        return a[0] - b[0];\r\n    });\r\n    variogram.range = distance[(n * n - n) / 2 - 1][0];\r\n\r\n    // Bin lag distance\r\n    var lags = (n * n - n) / 2 > 30 ? 30 : (n * n - n) / 2;\r\n    var tolerance = variogram.range / lags;\r\n    var lag = createArrayWithValues(0, lags);\r\n    var semi = createArrayWithValues(0, lags);\r\n    if (lags < 30) {\r\n        for (l = 0; l < lags; l++) {\r\n            lag[l] = distance[l][0];\r\n            semi[l] = distance[l][1];\r\n        }\r\n    } else {\r\n        for (i = 0, j = 0, k = 0, l = 0; i < lags && j < (n * n - n) / 2; i++, k = 0) {\r\n            while (distance[j][0] <= (i + 1) * tolerance) {\r\n                lag[l] += distance[j][0];\r\n                semi[l] += distance[j][1];\r\n                j++;\r\n                k++;\r\n                if (j >= (n * n - n) / 2) break;\r\n            }\r\n            if (k > 0) {\r\n                lag[l] /= k;\r\n                semi[l] /= k;\r\n                l++;\r\n            }\r\n        }\r\n        if (l < 2) return variogram; // Error: Not enough points\r\n    }\r\n\r\n    // Feature transformation\r\n    n = l;\r\n    variogram.range = lag[n - 1] - lag[0];\r\n    var X = createArrayWithValues(1, 2 * n);\r\n    var Y = Array(n);\r\n    var A = variogram.A;\r\n    for (i = 0; i < n; i++) {\r\n        switch (model) {\r\n            case \"gaussian\":\r\n                X[i * 2 + 1] = 1.0 - Math.exp(-(1.0 / A) * Math.pow(lag[i] / variogram.range, 2));\r\n                break;\r\n            case \"exponential\":\r\n                X[i * 2 + 1] = 1.0 - Math.exp((-(1.0 / A) * lag[i]) / variogram.range);\r\n                break;\r\n            case \"spherical\":\r\n                X[i * 2 + 1] = 1.5 * (lag[i] / variogram.range) - 0.5 * Math.pow(lag[i] / variogram.range, 3);\r\n                break;\r\n        }\r\n        Y[i] = semi[i];\r\n    }\r\n\r\n    // Least squares\r\n    var Xt = kriging_matrix_transpose(X, n, 2);\r\n    var Z = kriging_matrix_multiply(Xt, X, 2, n, 2);\r\n    Z = kriging_matrix_add(Z, kriging_matrix_diag(1 / alpha, 2), 2, 2);\r\n    var cloneZ = Z.slice(0);\r\n    if (kriging_matrix_chol(Z, 2)) kriging_matrix_chol2inv(Z, 2);\r\n    else {\r\n        kriging_matrix_solve(cloneZ, 2);\r\n        Z = cloneZ;\r\n    }\r\n    var W = kriging_matrix_multiply(kriging_matrix_multiply(Z, Xt, 2, 2, n), Y, 2, n, 1);\r\n\r\n    // Variogram parameters\r\n    variogram.nugget = W[0];\r\n    variogram.sill = W[1] * variogram.range + variogram.nugget;\r\n    variogram.n = x.length;\r\n\r\n    // Gram matrix with prior\r\n    n = x.length;\r\n    var K = Array<number>(n * n);\r\n    for (i = 0; i < n; i++) {\r\n        for (j = 0; j < i; j++) {\r\n            K[i * n + j] = modelFn(\r\n                Math.pow(Math.pow(x[i] - x[j], 2) + Math.pow(y[i] - y[j], 2), 0.5),\r\n                variogram.nugget,\r\n                variogram.range,\r\n                variogram.sill,\r\n                variogram.A\r\n            );\r\n            K[j * n + i] = K[i * n + j];\r\n        }\r\n        K[i * n + i] = modelFn(0, variogram.nugget, variogram.range, variogram.sill, variogram.A);\r\n    }\r\n\r\n    // Inverse penalized Gram matrix projected to target vector\r\n    var C = kriging_matrix_add(K, kriging_matrix_diag(sigma2, n), n, n);\r\n    var cloneC = C.slice(0);\r\n    if (kriging_matrix_chol(C, n)) kriging_matrix_chol2inv(C, n);\r\n    else {\r\n        kriging_matrix_solve(cloneC, n);\r\n        C = cloneC;\r\n    }\r\n\r\n    // Copy unprojected inverted matrix as K\r\n    var K = C.slice(0);\r\n    var M = kriging_matrix_multiply(C, t, n, n, 1);\r\n    variogram.K = K;\r\n    variogram.M = M;\r\n\r\n    return variogram;\r\n}\r\n\r\nexport function predict(x: number, y: number, variogram: Variogram) {\r\n    const M = Array(variogram.n);\r\n    const modelFn = getModelFn(variogram.model);\r\n    for (let i = 0; i < variogram.n; i++) {\r\n        M[i] = modelFn(\r\n            Math.hypot(x - variogram.x[i], y - variogram.y[i]),\r\n            variogram.nugget,\r\n            variogram.range,\r\n            variogram.sill,\r\n            variogram.A\r\n        );\r\n    }\r\n    return kriging_matrix_multiply(M, variogram.M, 1, variogram.n, 1)[0];\r\n}\r\n\r\n\r\n\r\nexport function variance(x: number, y: number, variogram: Variogram) {\r\n    const M = Array(variogram.n);\r\n    const modelFn = getModelFn(variogram.model);\r\n    for (let i = 0; i < variogram.n; i++)\r\n        M[i] = modelFn(\r\n            Math.pow(Math.pow(x - variogram.x[i], 2) + Math.pow(y - variogram.y[i], 2), 0.5),\r\n            variogram.nugget,\r\n            variogram.range,\r\n            variogram.sill,\r\n            variogram.A\r\n        );\r\n    return (\r\n        modelFn(0, variogram.nugget, variogram.range, variogram.sill, variogram.A) +\r\n        kriging_matrix_multiply(\r\n            kriging_matrix_multiply(M, variogram.K, 1, variogram.n, variogram.n),\r\n            M,\r\n            1,\r\n            variogram.n,\r\n            1\r\n        )[0]\r\n    );\r\n}\r\n\r\n","/**\n * @module LRUCache\n */\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache {\n    // options that cannot be changed without disaster\n    #max;\n    #maxSize;\n    #dispose;\n    #onInsert;\n    #disposeAfter;\n    #fetchMethod;\n    #memoMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    #hasOnInsert;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    get memoMethod() {\n        return this.#memoMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.onInsert} (read-only)\n     */\n    get onInsert() {\n        return this.#onInsert;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (memoMethod !== undefined &&\n            typeof memoMethod !== 'function') {\n            throw new TypeError('memoMethod must be a function if defined');\n        }\n        this.#memoMethod = memoMethod;\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof onInsert === 'function') {\n            this.#onInsert = onInsert;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasOnInsert = !!this.#onInsert;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the number of ms left in the item's TTL. If item is not in cache,\n     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.#delete(this.#keyList[index], 'expire');\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */\n                if (!ttl || !start)\n                    return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * A String value that is used in the creation of the default string\n     * description of an object. Called by the built-in method\n     * `Object.prototype.toString`.\n     */\n    [Symbol.toStringTag] = 'LRUCache';\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from most\n     * recently used to least recently used.\n     *\n     * `fn` is called as `fn(value, key, cache)`.\n     *\n     * If `thisp` is provided, function will be called in the `this`-context of\n     * the provided object, or the cache if no `thisp` object is provided.\n     *\n     * Does not update age or recenty of use, or iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.#delete(this.#keyList[i], 'expire');\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Returns `undefined` if the key is not present.\n     *\n     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n     * serialization, the `start` value is always the current timestamp, and the\n     * `ttl` is a calculated remaining time to live (negative if expired).\n     *\n     * Always returns stale values, if their info is found in the cache, so be\n     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n     * if relevant.\n     */\n    info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined)\n            return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v)\n            ? v.__staleWhileFetching\n            : v;\n        if (value === undefined)\n            return undefined;\n        const entry = { value };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to {@link LRUCache#load}.\n     *\n     * The `start` fields are calculated relative to a portable `Date.now()`\n     * timestamp, even if `performance.now()` is available.\n     *\n     * Stale entries are always included in the `dump`, even if\n     * {@link LRUCache.OptionsBase.allowStale} is false.\n     *\n     * Note: this returns an actual array, not a generator, so it can be more\n     * easily passed around.\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     *\n     * The shape of the resulting cache may be different if the same options are\n     * not used in both caches.\n     *\n     * The `start` fields are assumed to be calculated relative to a portable\n     * `Date.now()` timestamp, even if `performance.now()` is available.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     *\n     * Fields on the {@link LRUCache.SetOptions} options param will override\n     * their corresponding values in the constructor options for the scope\n     * of this single `set()` operation.\n     *\n     * If `start` is provided, then that will set the effective start\n     * time for the TTL calculation. Note that this must be a previous\n     * value of `performance.now()` if supported, or a previous value of\n     * `Date.now()` if not.\n     *\n     * Options object may also include `size`, which will prevent\n     * calling the `sizeCalculation` function and just use the specified\n     * number if it is a positive integer, and `noDisposeOnSet` which\n     * will prevent calling a `dispose` function in the case of\n     * overwrites.\n     *\n     * If the `size` (or return value of `sizeCalculation`) for a given\n     * entry is greater than `maxEntrySize`, then the item will not be\n     * added to the cache.\n     *\n     * Will update the recency of the entry.\n     *\n     * If the value is `undefined`, then this is an alias for\n     * `cache.delete(key)`. `undefined` is never stored in the cache.\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.#delete(k, 'set');\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n            if (this.#hasOnInsert) {\n                this.#onInsert?.(v, k, 'add');\n            }\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n            if (this.#hasOnInsert) {\n                this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace');\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Check if a key is in the cache, without updating the recency of\n     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n     * to `true` in either the options or the constructor.\n     *\n     * Will return `false` if the item is stale, even though it is technically in\n     * the cache. The difference can be determined (if it matters) by using a\n     * `status` argument, and inspecting the `has` field.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined ||\n            (!allowStale && this.#isStale(index))) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.#delete(k, 'fetch');\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.#delete(k, 'fetch');\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    async forceFetch(k, fetchOptions = {}) {\n        const v = await this.fetch(k, fetchOptions);\n        if (v === undefined)\n            throw new Error('fetch() returned undefined');\n        return v;\n    }\n    memo(k, memoOptions = {}) {\n        const memoMethod = this.#memoMethod;\n        if (!memoMethod) {\n            throw new Error('no memoMethod provided to constructor');\n        }\n        const { context, forceRefresh, ...options } = memoOptions;\n        const v = this.get(k, options);\n        if (!forceRefresh && v !== undefined)\n            return v;\n        const vv = memoMethod(k, v, {\n            options,\n            context,\n        });\n        this.set(k, vv, options);\n        return vv;\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.#delete(k, 'expire');\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     *\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        return this.#delete(k, 'delete');\n    }\n    #delete(k, reason) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.#clear(reason);\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, reason);\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, reason]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        return this.#clear('delete');\n    }\n    #clear(reason) {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, reason);\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, reason]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","import type { KrigingModel } from \"./kriging\";\r\n\r\nexport type ColorMappingItem = { min: number, max: number, color: string };\r\nexport type GL = WebGLRenderingContext | WebGL2RenderingContext;\r\n\r\nexport const isWorker = typeof importScripts !== 'undefined';\r\nexport const SupportOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\r\n\r\nexport const ModelCode = {\r\n    gaussian: 1,\r\n    exponential: 2,\r\n    spherical: 3,\r\n} as const;\r\nexport const OutputType = {\r\n    'packed-imagebitmap': 1,\r\n    'value-buffer': 2,\r\n    'imagebitmap': 3\r\n} as const;\r\nexport const MAX_STOPS = 256;\r\n\r\n\r\nexport class VariogramObject {\r\n    _model: KrigingModel;\r\n    _n: number; //variogram.n\r\n    _params: [number, number, number, number];//variogram.nugget, variogram.range, variogram.sill, variogram.A\r\n    _texture: WebGLTexture;\r\n    _textureSize: number[];\r\n    dispose: () => void;\r\n}\r\nexport class ColorMappingObject {\r\n    _texture: WebGLTexture;\r\n    _textureSize: number[];\r\n    _stopCount: number;\r\n    dispose: () => void;\r\n}\r\n\r\nexport const colorToRGBA = (() => {\r\n    let init = false;\r\n    let canvas: HTMLCanvasElement | OffscreenCanvas;\r\n    let ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\r\n    const map = {} as Record<string, number[]>;\r\n    return (colorStr: string) => {\r\n        if (!init) {\r\n            canvas = isWorker ? new OffscreenCanvas(1, 1) : document.createElement('canvas');\r\n            canvas.width = canvas.height = 1;\r\n            ctx = canvas.getContext('2d', { willReadFrequently: true }) as (CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D);\r\n            init = true;\r\n        }\r\n        if (!map[colorStr]) {\r\n            ctx.fillStyle = colorStr;\r\n            ctx.fillRect(0, 0, 1, 1);\r\n            const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;\r\n            map[colorStr] = [r, g, b, a];\r\n        }\r\n        return map[colorStr]\r\n    }\r\n})();\r\n\r\nexport function withResolvers<T>() {\r\n    let resolve: (t: T) => void;\r\n    let reject: (e?: any) => void;\r\n    const promise = new Promise<T>((res, rej) => {\r\n        resolve = res;\r\n        reject = rej;\r\n    });\r\n    return { promise, resolve, reject }\r\n}\r\nexport function getTextureUnpackAlign(rowBytes: number) {\r\n    return !(rowBytes & 0b111) ? 8 : !(rowBytes & 0b11) ? 4 : !(rowBytes & 0b1) ? 2 : 1;\r\n}\r\nexport function calcDataTexSize(pixelCount: number) {\r\n    if (!pixelCount) throw new Error(\"长度不存在!\");\r\n    const length = ceilPowerOfTwo(Math.ceil(pixelCount));\r\n    const l = Math.log2(length);\r\n    const cols = Math.ceil(l / 2);\r\n    const rows = l - cols;\r\n    return [2 ** cols, 2 ** rows];\r\n}\r\nexport function ceilPowerOfTwo(val: number) {\r\n    if (val & (val - 1)) {\r\n        val |= val >> 1;\r\n        val |= val >> 2;\r\n        val |= val >> 4;\r\n        val |= val >> 8;\r\n        val |= val >> 16;\r\n        return val + 1;\r\n    } else {\r\n        return val === 0 ? 1 : val;\r\n    }\r\n}\r\nexport function assert(condition: boolean, msg: string) {\r\n    if (!condition) throw new Error(msg);\r\n}\r\n\r\nfunction fract(v: number) {\r\n    return v - Math.floor(v);\r\n}\r\n\r\n//输出为归一化值\r\nexport function packNormalizeFloatToRGBA(v: number) {\r\n    if (v < 0 || v > 1) throw new Error(\"value must be in [0, 1]\");\r\n    // v = v * 255;\r\n    // const r = Math.floor(v);\r\n    // v = (v - r) * 255;\r\n    // const g = Math.floor(v);\r\n    // v = (v - g) * 255;\r\n    // const b = Math.floor(v);\r\n    // v = (v - b) * 255;\r\n    // const a = Math.floor(v);\r\n    // return [r, g, b, a].map((i) => i / 255);\r\n    const enc = [v, fract(v * 255), fract(v * 65025), fract(v * 16581375)];\r\n    return [\r\n        enc[0] - enc[1] / 255,\r\n        enc[1] - enc[2] / 255,\r\n        enc[2] - enc[3] / 255,\r\n        enc[3], //\r\n    ];\r\n}\r\n//输入为归一化值 rgba∈[0,1]\r\nexport function unpackRGBAToNormalizeFloat(normalized_rgba: number[]) {\r\n    const [r, g, b, a] = normalized_rgba;\r\n    return r + g / 255 + b / 65025 + a / 16581375;\r\n}","import { MAX_STOPS, ModelCode, OutputType } from \"../supports\";\r\n\r\nexport const glsl_pack = `\r\nvec4 packNormalizeFloatToRGBA( in float v ) {\r\n    vec4 enc = vec4(v, fract(vec3(255.0, 65025.0, 16581375.0) * v));\r\n    enc.xyz -= enc.yzw / 255.0; \r\n    return enc;\r\n}\r\nfloat unpackRGBAToNormalizeFloat( const in vec4 v ) {\r\n    return dot(v, vec4(1, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\r\n}\r\nvec3 packNormalizeFloatToRGB( in float v ) {\r\n\treturn packNormalizeFloatToRGBA( v ).xyz;\r\n}\r\nfloat unpackRGBToNormalizeFloat( const in vec3 v ) {\r\n\treturn unpackRGBAToNormalizeFloat( vec4( v, 0 ) );\r\n}\r\n`;\r\nexport const glsl_kriging = `\r\n#define MODEL_GAUSSIAN ${ModelCode.gaussian.toFixed(1)}\r\n#define MODEL_EXPONENTIAL ${ModelCode.exponential.toFixed(1)}\r\n#define MODEL_SPHERICAL ${ModelCode.spherical.toFixed(1)}\r\n\r\nstruct Variogram {\r\n    float nugget;\r\n    float range;\r\n    float sill;\r\n    float A;\r\n};\r\n\r\nfloat variogram_gaussian(float h, const Variogram p){\r\n    float i = -(1.0 / p.A) * pow(h / p.range, 2.0);\r\n    return p.nugget + ((p.sill - p.nugget) / p.range) * (1.0 - exp(i));\r\n}\r\nfloat variogram_exponential(float h, const Variogram p){\r\n    float i = -(1.0 / p.A) * (h / p.range);\r\n    return p.nugget + ((p.sill - p.nugget) / p.range) * (1.0 - exp(i));\r\n}\r\nfloat variogram_spherical(float h, const Variogram p){\r\n    if (h > p.range) return p.nugget + (p.sill - p.nugget) / p.range;\r\n    return p.nugget + ((p.sill - p.nugget) / p.range) * (1.5 * (h / p.range) - 0.5 * pow(h / p.range, 3.0));\r\n}\r\nfloat modelValue(float model, float h, const Variogram p){\r\n    return model == MODEL_GAUSSIAN\r\n            ? variogram_gaussian(h, p) \r\n            : model == MODEL_EXPONENTIAL \r\n                ? variogram_exponential(h, p) \r\n                : variogram_spherical(h, p);\r\n}`;\r\nexport const glsl_colorMapping = `\r\nstruct Node {\r\n    float min;\r\n    float max;\r\n    vec4 color;\r\n};\r\nNode decode_classbreak(vec4 data){\r\n    float pack_rg = data.b;\r\n    float pack_ba = data.a;\r\n\r\n    vec4 color = vec4(\r\n        floor(pack_rg),\r\n        clamp(fract(pack_rg) * 1000.0, 0.0, 255.0),\r\n        floor(pack_ba),\r\n        clamp(fract(pack_ba) * 1000.0, 0.0, 255.0)\r\n    ) / 255.0;\r\n    return Node(data.r, data.g, color);\r\n}\r\n\r\nvec4 mappingColor(\r\n    sampler2D map, \r\n    int stopCount,\r\n    float value \r\n){\r\n    int left = 0;\r\n    int right = stopCount - 1;\r\n\r\n    vec4 headColor = vec4(0);\r\n    vec4 tailColor = vec4(0);\r\n\r\n    for(int i = 0; i < ${Math.log2(MAX_STOPS)}; i++){\r\n        if(left > right) break;\r\n        int middle = (left + right) / 2;\r\n        float x = (float(middle) + 0.5) / ${MAX_STOPS.toFixed(1)};\r\n        vec4 encodeData = texture2D(map, vec2(x, 0.5));\r\n        Node node = decode_classbreak(encodeData);\r\n        if(middle == 0) headColor = node.color;\r\n        if(middle == ${MAX_STOPS} - 1) tailColor = node.color;\r\n        if(node.min > value){\r\n            right = middle - 1;\r\n        }else if(node.max <= value){\r\n            left = middle + 1;\r\n        }else{\r\n            return node.color;\r\n        }\r\n    }\r\n    if(right < 0) return headColor;\r\n    if(left >= stopCount) return tailColor;\r\n}\r\n`;\r\nexport const glsl_fs_main = `\r\n    #define PACKED_IMAGEBITMAP ${OutputType[\"packed-imagebitmap\"].toFixed(1)}\r\n    #define VALUE_BUFFER ${OutputType[\"value-buffer\"].toFixed(1)}\r\n    #define IMAGEBITMA ${OutputType[\"imagebitmap\"].toFixed(1)}\r\n\r\n    #ifdef webgl2\r\n        layout(std140) uniform DefaultUBO {\r\n            vec3 u_gridInfo;\r\n            float u_dimension;\r\n\r\n            vec2 u_variogramMxySize;\r\n            vec2 u_packValueRange; \r\n\r\n            vec4 u_variogramParam;\r\n\r\n            float u_model;\r\n            float u_classbreakCount;\r\n            float u_outputFormat;\r\n        };\r\n    #else\r\n        uniform vec3 u_gridInfo; // xmin, ymin, cellSize \r\n        uniform float u_dimension;\r\n\r\n        uniform vec2 u_variogramMxySize;\r\n        uniform vec2 u_packValueRange; \r\n\r\n        uniform vec4 u_variogramParam; //nugget, range, sill, A\r\n\r\n        uniform float u_model;\r\n        uniform float u_classbreakCount;\r\n        uniform float u_outputFormat;\r\n    #endif\r\n\r\n\r\n    uniform sampler2D u_variogramMxyTexture; \r\n    uniform sampler2D u_colormappingTexture; \r\n    ${glsl_pack}\r\n    ${glsl_kriging}\r\n    ${glsl_colorMapping}\r\n    vec3 lookup(float index){\r\n        float col = mod(index, u_variogramMxySize.x);\r\n        float row = floor(index / u_variogramMxySize.x);\r\n        vec2 pixel = 1.0 / u_variogramMxySize;\r\n        vec2 uv = vec2(col, row) * pixel + pixel * 0.5;\r\n        return texture2D(u_variogramMxyTexture, uv).xyz;\r\n    }\r\n        \r\n    float hypot(float a, float b){\r\n        return pow(pow(a,2.0) + pow(b,2.0), 0.5);\r\n    }\r\n\r\n    void main(){\r\n        Variogram variogram = Variogram(\r\n            u_variogramParam.x,\r\n            u_variogramParam.y,\r\n            u_variogramParam.z,\r\n            u_variogramParam.w\r\n        );\r\n        vec2 inputCoord = gl_FragCoord.xy * u_gridInfo.z + u_gridInfo.xy;\r\n        int max_i = int(u_dimension);\r\n        float sum = 0.0;\r\n        for(int i = 0; i < 1024; i++){\r\n            if(i == max_i) break;\r\n            vec3 mxy = lookup(float(i));\r\n            sum += modelValue(\r\n                u_model, \r\n                hypot(inputCoord.x - mxy[1], inputCoord.y - mxy[2]),\r\n                variogram\r\n            ) * mxy[0];\r\n        }\r\n                \r\n        if(u_outputFormat == PACKED_IMAGEBITMAP){\r\n            float normalizedSum = (sum - u_packValueRange.x) / (u_packValueRange.y - u_packValueRange.x);\r\n            gl_FragColor.rgb = packNormalizeFloatToRGB(normalizedSum);\r\n            gl_FragColor.a = 1.0;\r\n\r\n        }else if(u_outputFormat == VALUE_BUFFER){\r\n            gl_FragColor = vec4(sum, 0, 0, 1);\r\n        }else{\r\n            gl_FragColor = mappingColor(u_colormappingTexture, int(u_classbreakCount), sum);\r\n        }\r\n    }\r\n`\r\n","import type { Variogram } from \"../kriging\";\r\nimport { assert, calcDataTexSize, ColorMappingObject, colorToRGBA, getTextureUnpackAlign, isWorker, MAX_STOPS, SupportOffscreenCanvas, VariogramObject, type ColorMappingItem, type GL } from \"../supports\";\r\n\r\n\r\nfunction initGlCtx() {\r\n    let canvas: HTMLCanvasElement | OffscreenCanvas;\r\n    if (isWorker) {\r\n        assert(SupportOffscreenCanvas, 'OffscreenCanvas unsupport');\r\n        canvas = new OffscreenCanvas(1, 1);\r\n    } else {\r\n        canvas = SupportOffscreenCanvas\r\n            ? new OffscreenCanvas(1, 1)\r\n            : document.createElement('canvas')\r\n    }\r\n    const opts = {\r\n        alpha: false,\r\n        depth: false,\r\n        stencil: false,\r\n    }\r\n    const gl = (canvas.getContext('webgl2', opts) || canvas.getContext('webgl', opts)) as GL;\r\n    assert(!!gl, \"webgl unsupport\");\r\n\r\n    const isWEBGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\r\n    const extensions = {} as Record<string, any>;\r\n\r\n    const getExtension = (name: 'EXT_color_buffer_float' | 'OES_texture_float') => {\r\n        return extensions[name] ??= (gl.getExtension(name) ?? false)\r\n    };\r\n\r\n    return {\r\n        canvas,\r\n        gl,\r\n        isWEBGL2,\r\n        getExtension,\r\n    } as ({\r\n        canvas: HTMLCanvasElement | OffscreenCanvas;\r\n        getExtension: typeof getExtension\r\n    } & ({ gl: WebGL2RenderingContext, isWEBGL2: true } | { gl: WebGLRenderingContext, isWEBGL2: false }))\r\n}\r\nlet glCtx: ReturnType<typeof initGlCtx>;\r\nexport function getGLCtx() {\r\n    return glCtx ??= initGlCtx()\r\n}\r\n\r\nfunction createShader(gl: GL, type: number, source: string) {\r\n    const shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (success) return shader;\r\n    const errinfo = gl.getShaderInfoLog(shader);\r\n    gl.deleteShader(shader);\r\n    throw new Error(errinfo);\r\n}\r\n\r\nexport function createProgram(\r\n    gl: GL,\r\n    [vertexShaderSource, fragmentShaderSource]: string[]\r\n) {\r\n    const program = gl.createProgram();\r\n    const vShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\r\n    const fShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\r\n    gl.attachShader(program, vShader);\r\n    gl.attachShader(program, fShader);\r\n    gl.linkProgram(program);\r\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    gl.deleteShader(vShader);\r\n    gl.deleteShader(fShader);\r\n    if (success) return program;\r\n    const errInfo = gl.getProgramInfoLog(program);\r\n    gl.deleteProgram(program);\r\n    throw new Error(errInfo);\r\n}\r\n\r\nexport function createColorMappingObject(stops: ColorMappingItem[]) {\r\n    const { gl, getExtension, isWEBGL2 } = getGLCtx();\r\n    assert(stops?.length && stops.length <= 256, 'stops length must in [1, 256]')\r\n    for (let i = 0; i < stops.length; i++) {\r\n        const { min, max, color } = stops[i];\r\n        assert(min < max, 'stop not satisify: min < max');\r\n        assert(!!color, 'stop color not exist');\r\n        if (i === 0) continue;\r\n        const before = stops[i - 1];\r\n        assert(before.max === min, \"stop not satisify item[i].max == item[i+1].min\");\r\n    }\r\n    const data = new Float32Array(MAX_STOPS * 4);\r\n    for (let i = 0; i < stops.length; i++) {\r\n        const { min, max, color } = stops[i];\r\n        const [r, g, b, a] = colorToRGBA(color);\r\n        const cursor = i * 4;\r\n        data[cursor] = min;\r\n        data[cursor + 1] = max;\r\n        //in fragment if highp not support(example in mobile), use mediump:  2^14 = 16384, precesion = 2^-10\r\n        data[cursor + 2] = r + g / 1000;\r\n        data[cursor + 3] = b + a / 1000;\r\n    }\r\n\r\n    if (!isWEBGL2) {\r\n        assert(getExtension('OES_texture_float'), 'webgl float texture unsupport');\r\n    }\r\n    const texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 8);\r\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n    gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        0,\r\n        isWEBGL2 ? gl.RGBA32F : gl.RGBA,\r\n        MAX_STOPS,\r\n        1,\r\n        0,\r\n        gl.RGBA,\r\n        gl.FLOAT,\r\n        data\r\n    );\r\n    gl.bindTexture(gl.TEXTURE_2D, null);\r\n\r\n    const obj = new ColorMappingObject();\r\n    obj._texture = texture;\r\n    obj._textureSize = [MAX_STOPS, 1];\r\n    obj._stopCount = stops.length;\r\n    obj.dispose = () => gl.deleteTexture(texture);\r\n    return obj;\r\n}\r\n\r\nexport function createVariogramObject(variogram: Variogram) {\r\n    const { gl, getExtension: supportExtension, isWEBGL2 } = getGLCtx();\r\n    assert(variogram.n <= 1024, 'Supports up to 1024 points');\r\n    const [width, height] = calcDataTexSize(variogram.n);\r\n    const { M, x, y } = variogram;\r\n    const array = new Float32Array(width * height * 4);\r\n    for (let i = 0; i < variogram.n; i++) {\r\n        const cursor = i * 4;\r\n        array[cursor] = M[i];\r\n        array[cursor + 1] = x[i];\r\n        array[cursor + 2] = y[i];\r\n    }\r\n    if (!isWEBGL2) {\r\n        assert(supportExtension('OES_texture_float'), 'webgl float texture unsupport');\r\n    }\r\n    const texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, getTextureUnpackAlign(width));\r\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n    gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        0,\r\n        isWEBGL2 ? gl.RGBA32F : gl.RGBA,\r\n        width,\r\n        height,\r\n        0,\r\n        gl.RGBA,\r\n        gl.FLOAT,\r\n        array\r\n    );\r\n    gl.bindTexture(gl.TEXTURE_2D, null);\r\n\r\n    const obj = new VariogramObject();\r\n    obj._model = variogram.model;\r\n    obj._n = variogram.n;\r\n    obj._params = [variogram.nugget, variogram.range, variogram.sill, variogram.A];\r\n    obj._texture = texture;\r\n    obj._textureSize = [width, height];\r\n    obj.dispose = () => gl.deleteTexture(texture);\r\n    return obj;\r\n}","import { LRUCache } from \"lru-cache\";\r\nimport type { Variogram } from \"../kriging\";\r\nimport { assert, ColorMappingObject, ModelCode, OutputType, SupportOffscreenCanvas, VariogramObject, withResolvers, type ColorMappingItem } from \"../supports\";\r\nimport { glsl_fs_main } from \"./glsl\";\r\nimport { createColorMappingObject, createProgram, createVariogramObject, getGLCtx } from \"./utils\";\r\n\r\ntype P = {\r\n    variogram: Variogram | VariogramObject;\r\n    llCorner: number[];\r\n    gridSize: number[];\r\n    cellSize: number;\r\n}\r\nlet ctx: ReturnType<typeof initGenerateCtx>;\r\nexport function getGenerateCtx() {\r\n    return ctx ??= initGenerateCtx();\r\n}\r\n\r\nfunction initGenerateCtx() {\r\n    const { gl, isWEBGL2, getExtension } = getGLCtx();\r\n\r\n    const prefixVs = isWEBGL2\r\n        ? `#version 300 es\r\n           #define attribute in\r\n           #define varying out\r\n           #define webgl2\r\n        ` : '';\r\n    const prefixFs = isWEBGL2\r\n        ? `#version 300 es\r\n           #define varying in\r\n           #define webgl2\r\n           #define texture2D texture\r\n           #define gl_FragColor out_color\r\n        \r\n           precision highp float;\r\n           precision highp sampler2D;\r\n           \r\n           out vec4 out_color;\r\n        `\r\n        : `\r\n            #ifdef GL_FRAGMENT_PRECISION_HIGH\r\n                precision highp float;\r\n                precision highp sampler2D;\r\n            #else\r\n                precision mediump float;\r\n                precision mediump sampler2D;\r\n            #endif\r\n        `;\r\n    const vs = prefixVs + `\r\n        attribute vec2 position;\r\n        void main(){  \r\n            gl_Position = vec4(position * 2.0 - 1.0, 0, 1); \r\n        }\r\n    `;\r\n    const fs = prefixFs + glsl_fs_main;\r\n\r\n\r\n    //only one program used, bind once is ok\r\n    const program = createProgram(gl, [vs, fs]);\r\n    gl.useProgram(program);\r\n\r\n    const location = gl.getAttribLocation(program, \"position\");\r\n    const buffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1]), gl.STATIC_DRAW);\r\n    gl.enableVertexAttribArray(location);\r\n    gl.vertexAttribPointer(location, 2, gl.FLOAT, false, 0, 0);\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n\r\n    type R = {\r\n        fbo: WebGLFramebuffer;\r\n        attachment: WebGLTexture,\r\n    }\r\n    const rtCache = new LRUCache<string, R>({\r\n        max: 10,\r\n        dispose: ({ fbo, attachment }) => {\r\n            gl.deleteFramebuffer(fbo);\r\n            gl.deleteTexture(attachment)\r\n        }\r\n    });\r\n\r\n    return {\r\n        setUniforms: initUniformAndTextureSetter(program),\r\n        createBufferRT,\r\n    }\r\n    function createBufferRT(width: number, height: number): R {\r\n        const key = `${width}-${height}`;\r\n        if (rtCache.has(key)) return rtCache.get(key);\r\n        const texture = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        if (!isWEBGL2) {\r\n            assert(getExtension('OES_texture_float'), 'webgl float texture unsupport');\r\n        } else {\r\n            assert(getExtension('EXT_color_buffer_float'), 'webgl2 EXT_color_buffer_float unsupport');\r\n        }\r\n\r\n        gl.texImage2D(\r\n            gl.TEXTURE_2D,\r\n            0,\r\n            isWEBGL2 ? gl.R32F : gl.RGBA,\r\n            width,\r\n            height,\r\n            0,\r\n            isWEBGL2 ? gl.RED : gl.RGBA,\r\n            gl.FLOAT,\r\n            null\r\n        );\r\n\r\n        const fbo = gl.createFramebuffer();\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n\r\n        // const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\r\n        // if (status !== gl.FRAMEBUFFER_COMPLETE) {\r\n        //     console.error('Framebuffer is not complete:', status);\r\n        //     debugger\r\n        // }\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n        const obj = {\r\n            fbo,\r\n            attachment: texture,\r\n        }\r\n        rtCache.set(key, obj);\r\n        return obj;\r\n    }\r\n}\r\n\r\nfunction initUniformAndTextureSetter(program: WebGLProgram) {\r\n    const { gl, isWEBGL2 } = getGLCtx();\r\n    const location_mxyTexture = gl.getUniformLocation(program, 'u_variogramMxyTexture');\r\n    const location_colormappingTexture = gl.getUniformLocation(program, 'u_colormappingTexture');\r\n    gl.uniform1i(location_mxyTexture, 0);\r\n    gl.uniform1i(location_colormappingTexture, 1);\r\n\r\n    if (isWEBGL2) {\r\n        const uboBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.UNIFORM_BUFFER, uboBuffer);\r\n        gl.bufferData(gl.UNIFORM_BUFFER, 4 * 4 * Float32Array.BYTES_PER_ELEMENT, gl.DYNAMIC_DRAW);\r\n\r\n        const blockIndex = gl.getUniformBlockIndex(program, 'DefaultUBO');\r\n        gl.uniformBlockBinding(program, blockIndex, 0); //将program的DefaultUBO绑定到全局的0位置\r\n        gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, uboBuffer); //设置全局的0位置uniform数据为uboBuffer\r\n\r\n        return ({ outputFormat, variogram, packValueRange, llCorner, cellSize, colorMapping }: {\r\n            outputFormat: keyof typeof OutputType,\r\n            variogram: VariogramObject,\r\n            llCorner: number[],\r\n            cellSize: number,\r\n            packValueRange?: number[],\r\n            colorMapping?: ColorMappingObject\r\n        }) => {\r\n            gl.bindBuffer(gl.UNIFORM_BUFFER, uboBuffer);\r\n            gl.bufferSubData(gl.UNIFORM_BUFFER, 0, new Float32Array([\r\n                //ROW\r\n                llCorner[0],\r\n                llCorner[1],\r\n                cellSize,\r\n                variogram._n,\r\n                //ROW\r\n                variogram._textureSize[0],\r\n                variogram._textureSize[1],\r\n                outputFormat === 'packed-imagebitmap' ? packValueRange[0] : NaN,\r\n                outputFormat === 'packed-imagebitmap' ? packValueRange[1] : NaN,\r\n                //ROW\r\n                variogram._params[0],\r\n                variogram._params[1],\r\n                variogram._params[2],\r\n                variogram._params[3],\r\n                //ROW\r\n                ModelCode[variogram._model],\r\n                outputFormat === 'imagebitmap' ? colorMapping._stopCount : NaN,\r\n                OutputType[outputFormat],\r\n                NaN,\r\n            ]))\r\n            gl.bindBuffer(gl.UNIFORM_BUFFER, null);\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, variogram._texture);\r\n            if (outputFormat === 'imagebitmap') {\r\n                gl.activeTexture(gl.TEXTURE0 + 1);\r\n                gl.bindTexture(gl.TEXTURE_2D, colorMapping._texture);\r\n            }\r\n        }\r\n    } else {\r\n        const keys = [\r\n            'outputFormat', 'gridInfo', 'dimension', 'variogramMxySize', 'packValueRange',\r\n            'variogramParam', 'model', 'classbreakCount'\r\n        ] as const;\r\n        const uniformLocations = keys.reduce((map, key) => {\r\n            map[key] = gl.getUniformLocation(program, 'u_' + key);\r\n            return map;\r\n        }, {} as Record<(typeof keys)[`${number}`], WebGLUniformLocation>)\r\n        return ({ outputFormat, variogram, packValueRange, llCorner, cellSize, colorMapping }: {\r\n            outputFormat: keyof typeof OutputType,\r\n            variogram: VariogramObject,\r\n            llCorner: number[],\r\n            cellSize: number,\r\n            packValueRange?: number[],\r\n            colorMapping?: ColorMappingObject\r\n        }) => {\r\n            gl.uniform3fv(uniformLocations.gridInfo, [llCorner[0], llCorner[1], cellSize]);\r\n            gl.uniform1f(uniformLocations.dimension, variogram._n);\r\n            gl.uniform2fv(uniformLocations.variogramMxySize, variogram._textureSize);\r\n            if (outputFormat === 'packed-imagebitmap') {\r\n                gl.uniform2fv(uniformLocations.packValueRange, packValueRange);\r\n            }\r\n            gl.uniform4fv(uniformLocations.variogramParam, variogram._params);\r\n            gl.uniform1f(uniformLocations.model, ModelCode[variogram._model]);\r\n            if (outputFormat === 'imagebitmap') {\r\n                gl.uniform1f(uniformLocations.classbreakCount, colorMapping._stopCount);\r\n                gl.activeTexture(gl.TEXTURE0 + 1);\r\n                gl.bindTexture(gl.TEXTURE_2D, colorMapping._texture);\r\n            }\r\n            gl.uniform1f(uniformLocations.outputFormat, OutputType[outputFormat]);\r\n\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, variogram._texture);\r\n        }\r\n    }\r\n}\r\ntype Cancelable<R> = Promise<R> & { cancel: () => void };\r\n\r\ntype PromiseReturnType<T> = T extends (...args: any[]) => Promise<infer R> ? R : any;\r\nfunction wrapQueue<\r\n    F extends (...args: any[]) => Promise<any>,\r\n    R = PromiseReturnType<F>,\r\n>(fn: F) {\r\n\r\n    type Task = {\r\n        resolve: (result: R) => void;\r\n        reject: (e: any) => void;\r\n        args: Parameters<F>\r\n    };\r\n    const queue = [] as Task[];\r\n    let curTask: Task;\r\n    return (...args: Parameters<F>) => {\r\n        const { promise, resolve, reject } = withResolvers<R>();\r\n        const task = { resolve, reject, args };\r\n        queue.unshift(task);\r\n        Promise.resolve().then(excute);\r\n        (promise as Cancelable<R>).cancel = () => {\r\n            reject();\r\n            if (task !== curTask) {\r\n                const index = queue.findIndex(i => i === task);\r\n                queue.splice(index, 1);\r\n            }\r\n        };\r\n        return promise as Cancelable<R>;\r\n    }\r\n    function excute() {\r\n        if (curTask) return;\r\n        if (!queue.length) return;\r\n        curTask = queue.pop();\r\n        fn.apply(null, curTask.args)\r\n            .then(result => curTask.resolve(result))\r\n            .catch(e => curTask.reject(e))\r\n            .finally(() => {\r\n                curTask = null;\r\n                excute();\r\n            });\r\n    }\r\n}\r\n\r\nfunction generate(opts: P & { outputFormat: 'value-buffer' }): Cancelable<Float32Array>;\r\nfunction generate(opts: P & { outputFormat: 'packed-imagebitmap', packValueRange: number[] }): Cancelable<ImageBitmap>;\r\nfunction generate(opts: P & { outputFormat: 'imagebitmap', colorMapping: ColorMappingItem[] | ColorMappingObject }): Cancelable<ImageBitmap>;\r\nfunction generate(opts: P & {\r\n    packValueRange?: number[];\r\n    colorMapping?: ColorMappingItem[] | ColorMappingObject;\r\n    outputFormat: keyof typeof OutputType;\r\n}) {\r\n    const { gl, canvas, isWEBGL2 } = getGLCtx();\r\n    const { createBufferRT, setUniforms } = getGenerateCtx();\r\n    const { llCorner, gridSize, cellSize, packValueRange, outputFormat } = opts;\r\n    assert(gridSize[0] > 0 && gridSize[1] > 0, 'gridsize can not be 0');\r\n    const variogram = opts.variogram instanceof VariogramObject\r\n        ? opts.variogram\r\n        : createVariogramObject(opts.variogram);\r\n    const colorMapping = outputFormat === 'imagebitmap'\r\n        ? opts.colorMapping instanceof ColorMappingObject\r\n            ? opts.colorMapping\r\n            : createColorMappingObject(opts.colorMapping)\r\n        : null;\r\n\r\n    //clear\r\n    canvas.width = gridSize[0];\r\n    canvas.height = gridSize[1];\r\n    let rt: ReturnType<typeof createBufferRT>;\r\n    if (outputFormat === 'value-buffer') {\r\n        rt = createBufferRT(canvas.width, canvas.height);\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, rt.fbo);\r\n    } else {\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    }\r\n    gl.viewport(0, 0, canvas.width, canvas.height);\r\n    gl.clearColor(0, 0, 0, 0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n    setUniforms({\r\n        outputFormat,\r\n        variogram,\r\n        packValueRange,\r\n        llCorner,\r\n        cellSize,\r\n        colorMapping\r\n    });\r\n\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n\r\n    if (outputFormat !== 'value-buffer') {\r\n        doClear();\r\n        if (SupportOffscreenCanvas) {\r\n            return Promise.resolve((canvas as OffscreenCanvas).transferToImageBitmap())\r\n        } else {\r\n            return createImageBitmap(canvas, {\r\n                imageOrientation: \"none\"\r\n            });\r\n        }\r\n    } else {\r\n        let result: Float32Array;\r\n        if (isWEBGL2) {\r\n            result = new Float32Array(canvas.width * canvas.height);\r\n            gl.readPixels(0, 0, canvas.width, canvas.height, (gl as WebGL2RenderingContext).RED, gl.FLOAT, result);\r\n        } else {\r\n            result = new Float32Array(canvas.width * canvas.height);\r\n            const arr = new Float32Array(canvas.width * canvas.height * 4);\r\n            gl.readPixels(0, 0, canvas.width, canvas.height, gl.RGBA, gl.FLOAT, arr);\r\n            for (let i = 0; i < arr.length; i += 4) {\r\n                result[i / 4] = arr[i]\r\n            };\r\n        }\r\n        doClear();\r\n        return Promise.resolve(result);\r\n    }\r\n\r\n    function doClear() {\r\n        if (!(opts.variogram instanceof VariogramObject)) {\r\n            variogram.dispose();\r\n        }\r\n        if (outputFormat === 'imagebitmap' && !(opts.colorMapping instanceof ColorMappingObject)) {\r\n            colorMapping.dispose();\r\n        }\r\n    }\r\n}\r\n\r\nexport const generate_WEBGL = wrapQueue(generate) as unknown as typeof generate;","import { createVariogramObject, generate_WEBGL, predict, train, type Variogram } from \"../src\";\r\nimport type { ColorMappingObject } from \"../src/supports\";\r\nimport { getGenerateCtx } from \"../src/webgl/generate\";\r\nimport { createColorMappingObject, getGLCtx } from \"../src/webgl/utils\";\r\n\r\nself.onmessage = async e => {\r\n    //手动初始化，避免初始化时间算入gernerate中\r\n    await getGLCtx();\r\n    await getGenerateCtx();\r\n\r\n    const result = await gernerateMulti(e.data.data);\r\n    self.postMessage({\r\n        id: e.data.id,\r\n        result,\r\n        success: true\r\n    }, [\r\n        result.imagebitmap, \r\n        result.packedImagebitmap, \r\n        result.rawBuffer.buffer, \r\n        result.valueBuffer.buffer\r\n    ]);\r\n}\r\n\r\nlet colorMapping_object: ColorMappingObject;\r\nexport async function gernerateMulti({ data, xs, ys, llCorner, cellSize, gridSize, colorMapping, packValueRange }: {\r\n    data: number[],\r\n    xs: number[],\r\n    ys: number[],\r\n    llCorner: number[],\r\n    cellSize: number,\r\n    gridSize: number[],\r\n    colorMapping: { min: number, max: number, color: string }[],\r\n    packValueRange: number[]\r\n}) {\r\n    colorMapping_object ??= createColorMappingObject(colorMapping); //in this example it not change\r\n\r\n    let start = performance.now();\r\n    const variogram = train(\r\n        data,\r\n        xs,\r\n        ys,\r\n        'exponential',\r\n        0,\r\n        10\r\n    );\r\n    const trainTime = performance.now() - start;\r\n    console.log(trainTime);\r\n    const variogram_object = createVariogramObject(variogram);\r\n\r\n    start = performance.now();\r\n    const rawBuffer = generate_normal(variogram, {\r\n        llCorner,\r\n        gridSize,\r\n        cellSize,\r\n    });\r\n    const time_rawBuffer = performance.now() - start;\r\n\r\n    start = performance.now();\r\n    const imagebitmap = await generate_WEBGL({\r\n        variogram: variogram_object,\r\n        llCorner,\r\n        cellSize,\r\n        gridSize,\r\n        colorMapping: colorMapping_object,\r\n        outputFormat: 'imagebitmap'\r\n    });\r\n    const time_imagebitmap = performance.now() - start;\r\n\r\n    start = performance.now();\r\n    const packedImagebitmap = await generate_WEBGL({\r\n        variogram: variogram_object,\r\n        llCorner,\r\n        cellSize,\r\n        gridSize,\r\n        packValueRange,\r\n        outputFormat: 'packed-imagebitmap'\r\n    });\r\n    const time_packedImagebitmap = performance.now() - start;\r\n\r\n    start = performance.now();\r\n    const valueBuffer = await generate_WEBGL({\r\n        variogram: variogram_object,\r\n        llCorner,\r\n        cellSize,\r\n        gridSize,\r\n        outputFormat: 'value-buffer'\r\n    });\r\n    const time_valuebuffer = performance.now() - start;\r\n\r\n    variogram_object.dispose();\r\n    return {\r\n        rawBuffer,\r\n        imagebitmap,\r\n        packedImagebitmap,\r\n        valueBuffer,\r\n        time_imagebitmap,\r\n        time_packedImagebitmap,\r\n        time_valuebuffer,\r\n        time_rawBuffer\r\n    }\r\n}\r\n\r\n\r\nfunction generate_normal(variogram: Variogram, opts: {\r\n    llCorner: number[],//[xmin, ymin]\r\n    cellSize: number; //网格大小\r\n    gridSize: number[];//网格数 [cols,rows]\r\n}) {\r\n    const { cellSize, llCorner, gridSize } = opts;\r\n    const [cols, rows] = gridSize;\r\n    const [xmin, ymin] = llCorner;\r\n    const halfSize = cellSize / 2;\r\n    const result = new Float32Array(cols * rows);\r\n    const [ox, oy] = [xmin + halfSize, ymin + halfSize]; \r\n    for (let i = 0; i < rows; i++) {\r\n        const cursor = (rows - 1 - i) * cols;\r\n        const y = oy + i * cellSize;\r\n        for (let j = 0; j < cols; j++) {\r\n            result[cursor + j] = predict(ox + j * cellSize, y, variogram);\r\n        }\r\n    }\r\n    return result;\r\n}"],"names":["v","bf","ctx"],"mappings":"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","x_google_ignoreList":[1]}